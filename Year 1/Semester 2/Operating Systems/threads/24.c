//Write a C program that creates N threads and one child process (N given as a command line argument). Each thread will receive a unique id from the parent. Each thread will generate two random numbers between 1 and 100 and will print them together with its own id. The threads will send their generated numbers to the child process via pipe or FIFO. The child process will calculate the average of each pair of numbers received from a thread and will print it alongside the thread id. Use efficient synchronization.

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/wait.h>

typedef struct{
	int id;
	pthread_mutex_t *mtx;
	int *p;
} data;	

void *fun(void *arg) {
	data d = *((data *) arg);
	
	int nr1, nr2;
	nr1 = random() % 101;
	nr2 = random() % 101;

	printf("Thread %d has generated: %d %d\n", d.id, nr1, nr2);

	pthread_mutex_lock(d.mtx);
	
	//close(d.p[0]); //nu citim aici
	if ( write(d.p[1], &nr1, sizeof(int)) < 0 ) {
		perror("error writing the first number");
		exit(1);
	} 
	
	
	if ( write(d.p[1], &nr2, sizeof(int)) < 0 ) {
		perror("error writing the second number");
		exit(1);
	} 
	
	//close(d.p[1]);
	pthread_mutex_unlock(d.mtx);

	return NULL;
}

int main(int argc, char *argv[]) {
	if ( argc != 2 ) {
		perror("you must provide one argument");
		exit(1);
	}
	
	int n = atoi(argv[1]);
	
	pthread_t *th = malloc(n * sizeof(pthread_t));
	pthread_mutex_t mtx;

	data *arg = malloc(n * sizeof(data));
	
	int p[2];
	
	if ( pipe(p) < 0 ) {
		perror("error while creating the pipe");
		exit(1);
	}

	int f = fork();
	
	if ( f < 0 ) { 
		perror("error creating the fork");
		exit(1);
	} 
	else if ( f == 0 ) { 
		//child
		
		close(p[1]); //nu scriem

		for ( int i = 0; i < n; ++i ) {
			int nr1, nr2;
			
			if ( read(p[0], &nr1, sizeof(int)) < 0 ) {
				perror("error reading the first generated number");
				exit(1);
			}

			
			if ( read(p[0], &nr2, sizeof(int)) < 0 ) {
				perror("error reading the second generated number");
				exit(1);
			}

			printf("The average of the numbers generated by thread %i is: %f\n", i, (double)((nr1 + nr2)/2));
		}
	
		free(arg);
		free(th);
		close(p[0]);
		exit(0);
	}
	else {
		//parent

		pthread_mutex_init(&mtx, NULL);
		
		close(p[0]);
		
		for ( int i = 0; i < n; ++i ) {
			arg[i].p = p;
			arg[i].mtx = &mtx;
			arg[i].id = i;
			
			pthread_create(&th[i], NULL, fun, (void *) &arg[i]);
		}
	
		for ( int i = 0; i < n; ++i ) 
			pthread_join(th[i], NULL);
	
		close(p[1]);
		pthread_mutex_destroy(&mtx);
		free(arg);
		free(th);
		wait(0);
	}

//	free(arg);
//	free(th);
	return 0;
}
